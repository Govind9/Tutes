Notation:
	If 'A' represents a source code of a program then
	'a' represents 'A' compiled.

Let C1 be the source code of a good, innocent version of the C compiler.
Let c1 be the binary for the good compiler.
Let C2 be the source code of a bad, malacious version of the C compiler.
Let c2 be the binary for the bad compiler.
Let P be the source code of any program.
Let p be the binary of P when compiler by c1.
Let B be the source of a backdoor bug.
Let b be the binary of a B when compiled by c1.

def C1(P): //When C1 gets P to compile.
	return p //return the binary of P

def C2(P): //When C2 gets P to compile.
	if P != C1: //If P is an ordinary program
		p' = p + b
		return p' //return a binary which contains p and b
	else: //If P is C1
		cc = c2 + b
		return cc //return c2 i.e. the malcious compiler binary which is now also affected by b.

Now what thompson did:
He used c1 to compile C2 and get C2.
He used c2 to compile C1 to get cc.
He then destroyed c1, B, C2, c2.
Now all that is left now is cc and C1.

So basically we have the source for a good compiler i.e. C1.
We have a compiler binary which is both malacious like (c2) and infected by (b) i.e. cc.

The whole world uses cc. cc gives a backdoor to any program it will compile. If cc is used to create a new compiler from a good source, then it will again give cc. So all we will get are programs that are infected and compilers that are both infected and malacious. And all of this is possible without their being any code for the bug or the initial bad compiler.

Defination of compile:
compile(X)
{
	Compile X manually and return the binary.
}

Source code of C1:
C1(X) 
{
	return x;
}

Source code of B:
B()
{
	add backdoor;
}

Action #1:
c1 = compile(C1);

Source code of C1:
C2(X)
{
	if (X == C1)
	{
		X = C2 + B;
		x = c1(X);
	}
	else
	{
		X = X + B;
		x = c1(X);
	}
	return x;
}

Action #2:
c2 = compile(C2);
cc = c2(C1);
delete C2
delete B
delete c1
delete compile();
